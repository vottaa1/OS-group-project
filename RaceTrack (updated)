import javax.swing.*;

import java.awt.*;
import java.util.List;
import java.util.ArrayList;

public class RaceTrack extends JPanel {

    private final int rows = 10;
    private final int cols = 30;
    private final int START_COL = 1;
    private final int FINISH_COL = cols - 1;
    private final int[][] grid = new int[rows][cols]; // just for visuals
    
    private volatile boolean raceOver = false;
    private car winner = null;

    private final List<car> cars = new ArrayList<>();
    private final Color[] colors = {Color.RED, Color.BLUE, Color.ORANGE, Color.CYAN};

    public RaceTrack(int numCars) {
        // Mark start and finish lines
        for (int r = 0; r < rows; r++) {
            grid[r][START_COL] = 3;
            grid[r][FINISH_COL] = 4;
        }

        if (numCars <= 0) numCars = 1;
        for (int i = 0; i < numCars; i++) {
            int row = (numCars == 1) ? rows / 2 : (i * (rows - 1)) / (numCars - 1);
            Color color = colors[i % colors.length];
            cars.add(new car(row, color));
        }
    }

    public synchronized boolean moveCar(car c) {
    	if (raceOver) return false;
    	
        int nextCol = c.col + 1;

        if (nextCol >= FINISH_COL) {
            c.col = FINISH_COL;
            SwingUtilities.invokeLater(this::repaint);
            return false; // finished
        }

        // prevent overlap
        for (car other : cars) {
            if (other != c && other.row == c.row && other.col == nextCol) return true;
        }

        c.col = nextCol;
        SwingUtilities.invokeLater(this::repaint);
        return true;
    }
    
    public synchronized boolean isRaceOver() {
    	return raceOver;    
    }
    
    public synchronized void declareWinner(car c) {
    	if(!raceOver) {
    		raceOver = true;
    		winner = c;
    		System.out.println(c.color + "car wins!");
    	}
    }

    public synchronized void resetCarsToStart() {
        for (car c : cars) c.col = 0;
        repaint();
    }

    @Override
    protected void paintComponent(Graphics g) {
        super.paintComponent(g);

        int cellWidth = getWidth() / cols;
        int cellHeight = getHeight() / rows;

        for (int r = 0; r < rows; r++) {
            for (int c = 0; c < cols; c++) {
                if (c == START_COL) g.setColor(Color.GREEN);
                else if (c == FINISH_COL) g.setColor(Color.BLACK);
                else g.setColor(Color.WHITE);

                g.fillRect(c * cellWidth, r * cellHeight, cellWidth, cellHeight);
                g.setColor(Color.GRAY);
                g.drawRect(c * cellWidth, r * cellHeight, cellWidth, cellHeight);
            }
        }

        for (car c : cars) {
            g.setColor(c.color);
            g.fillRect(c.col * cellWidth, c.row * cellHeight, cellWidth, cellHeight);
        }

        // START label
        Graphics2D g2 = (Graphics2D) g.create();
        g2.setColor(Color.WHITE);
        g2.setFont(new Font("Arial", Font.BOLD, 16));
        g2.rotate(-Math.PI / 2, START_COL * cellWidth + 16, getHeight() / 2.0);
        g2.drawString("START", START_COL * cellWidth, getHeight() / 2);
        g2.dispose();

        // FINISH label
        g2 = (Graphics2D) g.create();
        g2.setColor(Color.WHITE);
        g2.setFont(new Font("Arial", Font.BOLD, 16));
        g2.rotate(-Math.PI / 2, FINISH_COL * cellWidth + 16, getHeight() / 2.0);
        g2.drawString("FINISH", FINISH_COL * cellWidth + 5, getHeight() / 2);
        g2.dispose();
    }

    @Override
    public Dimension getPreferredSize() {
        return new Dimension(900, 450);
    }

    public List<car> getCars() {
        return cars;
    }
}
}
